
import { WordData } from '../types/word';

export type QuestionType = 'synonym' | 'antonym';

export interface QuizQuestion {
  id: string;
  type: QuestionType;
  targetWord: string; // The word displayed in the question
  correctAnswer: string; // The correct synonym or antonym
  options: string[]; // 4 options including the correct answer
}

// Helper to shuffle an array
const shuffle = <T>(array: T[]): T[] => {
  const newArray = [...array];
  for (let i = newArray.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
  }
  return newArray;
};

interface WordWithId {
    id: number;
    swedish_word: string;
    word_data: WordData | null;
}

export const generateQuiz = (
  words: { id: number; swedish_word: string; word_data: any }[],
  type: QuestionType,
  count: number = 10
): QuizQuestion[] => {
  const questions: QuizQuestion[] = [];
  
  // 1. Filter usable words
  const validWords = words.filter(word => {
    if (!word.word_data) return false;
    const data = word.word_data as WordData;
    if (type === 'synonym') {
      return data.synonyms && data.synonyms.length > 0;
    } else {
      return data.antonyms && data.antonyms.length > 0;
    }
  });

  if (validWords.length < 4) {
    // Not enough words to generate meaningful distractors
    console.warn('Not enough words with metadata to generate a quiz');
    return [];
  }

  // 2. Select random target words
  const shuffledWords = shuffle(validWords);
  const selectedTargets = shuffledWords.slice(0, count);

  selectedTargets.forEach(target => {
    const data = target.word_data as WordData;
    
    // 3. Determine correct answer
    // For now, take the first one or a random one from the list
    const sourceList = type === 'synonym' ? data.synonyms : data.antonyms;
    const correctAnswer = sourceList[Math.floor(Math.random() * sourceList.length)];

    // 4. Generate distractors
    // We need 3 distractors. They should be "answers" from OTHER words to look realistic.
    // Or we could just use random other words from the database?
    // Using random words from the DB might be too easy if they are totally unrelated POS.
    // Ideally we want words of similar POS.
    
    // Simple approach: Pick 3 random words from the *rest* of the list
    const otherWords = validWords.filter(w => w.id !== target.id);
    const distractors = shuffle(otherWords)
      .slice(0, 3)
      .map(w => {
         // Ideally use a synonym/antonym from that word to make it look like a valid answer option
         // e.g. if Question is "Synonym for Happy", distractors should be "Sad", "Blue", "Green" (adjectives)
         // But simply using the swedish_word itself might be confusing if the question is "What is a synonym for X?"
         // and options are [SynonymOfX, WordY, WordZ, WordA].
         // Wait, usually the question is:
         // "What is a synonym for 'Glad' (Happy)?" -> Options: "Lycklig" (Happy), "Ledsen" (Sad), "Arg" (Angry), "TrÃ¶tt" (Tired)
         // So distractors should be *other Swedish words* or *synonyms/antonyms of other words*?
         
         // Let's assume the question is: "Which word is a {type} for '{target.swedish_word}'?"
         // The options should be Swedish words.
         
         // The `correctAnswer` above was picked from `data.synonyms` which are likely Swedish words too?
         // Let's verify `word_data` structure. `synonyms` are string[].
         // If `synonyms` are Swedish words, then distractors should be other Swedish words.
         
         // BUT wait! `synonyms` in `word_data` generated by Gemini. Are they Swedish or English?
         // The prompt says: "You are a Swedish-English language expert. Provide a detailed explanation of the Swedish word..."
         // "List relevant synonyms." -> Usually implies Swedish synonyms for a Swedish word.
         // Let's assume they are Swedish.
         
         // So distractors should be distinct Swedish words to be plausible options.
         // We can just use `swedish_word` from other entries as distractors.
         return w.swedish_word; 
      });

    // Ensure we have unique options and enough distractors
    // (In a small DB, we might struggle, but let's assume >4 words)
    
    const options = shuffle([correctAnswer, ...distractors]);
    
    questions.push({
      id: `${target.id}-${Date.now()}`,
      type,
      targetWord: target.swedish_word,
      correctAnswer,
      options
    });
  });

  return questions;
};
